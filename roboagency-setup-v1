Autonomous AI Agency ‚Äî Build, Orchestrate & Scale (v1.0)

A practical, implementation-ready documentation suite for standing up a highly-automated, agent-driven AI studio on a VPS stack‚Äîaligned with ‚ÄúHumachine‚Äù principles (human creativity + machine efficiency) and the 4-I model (Intentionality ‚Üí Integration ‚Üí Implementation ‚Üí Indication).  Ôøº  Ôøº

‚∏ª

Table of Contents
	‚Ä¢	0. Intent & Scope
	‚Ä¢	1. System Architecture (ARCHITECTURE.md)
	‚Ä¢	2. Core Workflows & Diagrams (WORKFLOWS.md)
	‚Ä¢	3. Agents & Orchestration (AGENTS.md)
	‚Ä¢	4. Automations (AUTOMATIONS.md)
	‚Ä¢	5. APIs & Contracts (API_DOCUMENTATION.md)
	‚Ä¢	6. Data & Storage (DATA_MODEL.md)
	‚Ä¢	7. Naming, Ports & Repo Structure (CONVENTIONS.md)
	‚Ä¢	8. Deployment on VPS (DEPLOYMENT.md)
	‚Ä¢	9. Security, Compliance & Runbooks (SECURITY_POLICY.md, RUNBOOK.md)
	‚Ä¢	10. Roadmap, Costs & SLOs (ROADMAP.md)
	‚Ä¢	Appendix: Sample Files (.env, Docker, Nginx, CI/CD)

‚∏ª

0. Intent & Scope

Mission. Build the most automated, intelligent, and creatively sovereign AI agency on Earth by pairing human judgment and brand voice with machine scale, speed, and consistency. This explicitly follows Kasparov‚Äôs Law (‚Äúweak human + machine + better process > strong computer alone‚Äù), harnesses Moravec‚Äôs Paradox (let machines do what humans aren‚Äôt great at and vice-versa), and aims for collective superintelligence via a network of humans + AI + bots.  Ôøº

Operating model. Use the 4-I model to continuously improve: Intentionality (purpose, values) ‚Üí Integration (humans + agents + services) ‚Üí Implementation (experimentation, freedom to innovate) ‚Üí Indication (OKRs & telemetry), then loop.  Ôøº  Ôøº

‚∏ª

1. System Architecture (ARCHITECTURE.md)

1.1 High-level view

graph TD
  subgraph Frontend (SvelteKit)
    UI[Sector Picker & Intake Form]
    Portal[Client Portal]
  end
  subgraph Backend (FastAPI)
    Orchestrator[Agent Orchestrator (LangGraph/DSPy)]
    API[REST/Webhook API]
  end
  subgraph Data
    PG[(Supabase Postgres)]
    Obj[(S3/Spaces for Assets)]
    Vec[(Qdrant - embeddings)]
    Cache[(Redis)]
  end
  subgraph Automations
    n8n[n8n Flows]
    Email[(Resend SMTP)]
    CMS[(Content Source: MDX/Wagtail)]
  end
  subgraph Infra
    Nginx[NGINX / API Gateway]
    CF[Cloudflare WAF/SSL/DNS]
    Mon[UptimeRobot, Sentry, Analytics]
  end

  UI -->|Form submit| Nginx --> API --> Orchestrator
  Orchestrator --> PG
  Orchestrator --> Vec
  Orchestrator --> Obj
  Orchestrator --> Cache
  Orchestrator <-->|Triggers, Webhooks| n8n --> Email
  CMS -->|Publish Webhook| n8n
  Nginx --> CF
  Mon --> Nginx

Key platform choices (lean VPS, free/low-cost defaults):
	‚Ä¢	SvelteKit frontend, FastAPI backend; Nginx as reverse proxy/API gateway.
	‚Ä¢	Cloudflare for DNS/SSL/WAF; Resend for email (free tier noted).  Ôøº
	‚Ä¢	Hetzner CX21‚Äìclass VPS recommended; Dockerized services.  Ôøº
	‚Ä¢	Prioritized order of operations: Docker ‚Üí Domain+Cloudflare ‚Üí Server ‚Üí SSL ‚Üí Email ‚Üí Security ‚Üí (Optional) Microservices ‚Üí CI/CD ‚Üí Monitoring.  Ôøº

The above sequence (and the use of Cloudflare Origin certs + Resend setup) is directly aligned with your Quick Start and Deployment docs.  Ôøº  Ôøº

1.2 Services
	‚Ä¢	Frontend (SvelteKit): Sector picker, intake form, client portal, auth, status tracking.
	‚Ä¢	Backend (FastAPI): AuthN/Z, API/queues, LangGraph/DSPy agent graphs, job state machine.
	‚Ä¢	Automations (n8n): Webhook ingestion, DB writes, campaign email, calendar/scheduling, CMS distribution.
	‚Ä¢	Data: Supabase (core relational), Qdrant (vectors), S3/Spaces (assets), Redis (jobs/cache).
	‚Ä¢	Observability: Sentry + UptimeRobot + Cloudflare analytics.  Ôøº
	‚Ä¢	Security: Cloudflare WAF/Bot, Nginx headers, fail2ban, backups as per roadmap.  Ôøº

‚∏ª

2. Core Workflows & Diagrams (WORKFLOWS.md)

2.1 Client ‚ÄúSector ‚Üí Intake ‚Üí Warm Lead‚Äù (E2E)

sequenceDiagram
  participant U as User
  participant FE as SvelteKit (Form)
  participant GW as Nginx Gateway
  participant BE as FastAPI
  participant OR as Agent Orchestrator
  participant DB as Supabase
  participant N8 as n8n
  participant RS as Resend (Email)
  participant AS as Asset Store (S3/Spaces)

  U->>FE: Select sector + submit idea + email
  FE->>GW: POST /intake
  GW->>BE: route
  BE->>DB: Create Lead, Project, Intake
  BE->>OR: enqueue pipeline(workflow_id="proto_v1")
  OR->>OR: Generate product docs, wireframes, prototype
  OR->>AS: Upload artifacts (docs, assets)
  OR->>N8: webhook: lead_ready + asset URLs
  N8->>RS: Email #1 demo video (with asset link)
  N8->>RS: Email #2 prototype link
  N8->>RS: Email #3 schedule consult (Calendly link)

Outcome: Every lead arrives ‚Äúwarm + qualified‚Äù with demo + prototype + scheduled consult automatically.

2.2 Content ‚ÄúPublish ‚Üí Omnichannel Distribution‚Äù

flowchart LR
  CMS[(Blog Publish Webhook)] --> N8[n8n Flow]
  N8 --> LLM[Summarize & style: X/TikTok/Reels/YT]
  LLM --> Queue[/Scheduler/]
  Queue --> TW[Twitter/X API]
  Queue --> IG[IG Reels/TikTok Upload (via connector)]
  Queue --> YT[YouTube Shorts/Video Upload]
  Queue --> LI[LinkedIn Post]
  N8 --> RS[Newsletter via Resend]


‚∏ª

3. Agents & Orchestration (AGENTS.md)

3.1 Agent graph (LangGraph/DSPy)
	‚Ä¢	IntakeParser ‚Üí validates sector & intent, extracts goals/constraints.
	‚Ä¢	MarketMapper ‚Üí retrieves patterns, comps, and risks (templated from library).
	‚Ä¢	ProductDocWriter ‚Üí PRD, user stories, acceptance criteria.
	‚Ä¢	Wireframer ‚Üí low-fi wireframes (textual layout, optional Figma API integration).
	‚Ä¢	Prototyper ‚Üí scaffolds Svelte component(s) from PRD and wireframe plan.
	‚Ä¢	ExplainerProducer ‚Üí 60‚Äì90s script + voiceover plan + scene list; renders via ffmpeg pipeline or external studio.
	‚Ä¢	CampaignComposer ‚Üí 3-email warmup sequence (links to demo, prototype, calendar).
	‚Ä¢	QA/Indication ‚Üí health checks, validation, scoring; logs to telemetry (OKRs).

Process over horsepower: better process + human review points beats raw compute, per Kasparov‚Äôs Law. Embed purposeful guardrails (4-I).  Ôøº  Ôøº

Skeleton (Python):

# agents/orchestrator.py
from langgraph.graph import StateGraph, END
from dspy import ChainOfThought, Example

def intake_parser(state): ...
def product_doc_writer(state): ...
def wireframer(state): ...
def prototyper(state): ...
def explainer_producer(state): ...
def campaign_composer(state): ...
def indication_okrs(state): ...

g = StateGraph()
g.add_node("intake", intake_parser)
g.add_node("prd", product_doc_writer)
g.add_node("wireframe", wireframer)
g.add_node("prototype", prototyper)
g.add_node("video", explainer_producer)
g.add_node("campaign", campaign_composer)
g.add_node("indication", indication_okrs)

g.set_entry_point("intake")
g.add_edge("intake", "prd")
g.add_edge("prd", "wireframe")
g.add_edge("wireframe", "prototype")
g.add_edge("prototype", "video")
g.add_edge("video", "campaign")
g.add_edge("campaign", "indication")
g.add_edge("indication", END)
workflow = g.compile()


‚∏ª

4. Automations (AUTOMATIONS.md)

4.1 n8n ‚Äî Lead Warmup (importable JSON, trimmed)

{
  "nodes": [
    {"parameters": {"path": "lead/intake"}, "name": "Webhook", "type": "n8n-nodes-base.webhook"},
    {"parameters": {"functionCode": "return [{json: {lead: $json}}]"}, "name": "Extract"},
    {"parameters": {"operation": "insert", "table": "leads"}, "name": "Supabase"},
    {"parameters": {"method": "POST", "url": "https://api.agency.local/workflows/proto_v1"}, "name": "Trigger Orchestrator"},
    {"parameters": {"interval": 5, "unit": "minutes"}, "name": "WaitForArtifacts"},
    {"parameters": {"fromEmail": "hello@agency.com", "subject": "Your Demo", "text": "Link: {{$json.demo_url}}"}, "name": "Email #1 (Resend)"},
    {"parameters": {"fromEmail": "hello@agency.com", "subject": "Prototype", "text": "Play: {{$json.proto_url}}"}, "name": "Email #2 (Resend)"},
    {"parameters": {"fromEmail": "hello@agency.com", "subject": "Book a Call", "text": "Pick a slot: https://cal.com/you"}, "name": "Email #3 (Resend)"}
  ],
  "connections": { "Webhook": {"main":[ [{"node":"Extract"}] ]} }
}

Use Resend SMTP/API and set SPF/DKIM/DMARC in Cloudflare for deliverability.  Ôøº  Ôøº  Ôøº

4.2 n8n ‚Äî Content Distribution (trimmed)
	‚Ä¢	Trigger: POST /cms/published
	‚Ä¢	Steps: Summarize ‚Üí Formatters (X/TikTok/IG/LI/YT) ‚Üí Queue ‚Üí API posts ‚Üí Newsletter (Resend).

‚∏ª

5. APIs & Contracts (API_DOCUMENTATION.md)

Base URL: https://api.yourdomain.tld/v1
	‚Ä¢	POST /intake
	‚Ä¢	Body: { sector, idea, email, constraints? }
	‚Ä¢	201: { lead_id, project_id }
	‚Ä¢	POST /workflows/{id}
	‚Ä¢	Body: { lead_id, options? } ‚Üí returns { run_id, status }
	‚Ä¢	GET /runs/{run_id} ‚Üí { status, artifacts:[...] }
	‚Ä¢	POST /webhooks/agent/{event} (internal from Orchestrator)
	‚Ä¢	GET /assets/{id} (signed URLs)

Webhooks to n8n:
	‚Ä¢	lead_ready, artifacts_ready, failover_required

‚∏ª

6. Data & Storage (DATA_MODEL.md)

Core tables (Supabase/Postgres)

-- leads, projects, workflows, runs, assets, campaigns
CREATE TABLE leads(
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text NOT NULL, sector text, idea text, created_at timestamptz DEFAULT now()
);

CREATE TABLE projects(
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  lead_id uuid REFERENCES leads(id), status text, created_at timestamptz DEFAULT now()
);

CREATE TABLE workflow_runs(
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id uuid REFERENCES projects(id),
  name text, status text, metadata jsonb, created_at timestamptz DEFAULT now()
);

Vectors (Qdrant): store doc chunks, code embeddings, captions for retrieval-augmented generation.

Assets: object storage buckets: docs/, videos/, prototypes/.

‚∏ª

7. Naming, Ports & Repo Structure (CONVENTIONS.md)

Naming conventions
	‚Ä¢	Services: frontend, orchestrator, n8n, auth (service names in compose)
	‚Ä¢	Apps: frontend/, orchestrator/, n8n/, auth/ (folder names in apps/)
	‚Ä¢	Branches: feat/*, fix/*, chore/*, docs/*
	‚Ä¢	Env files: .env, .env.local, .env.production (never commit secrets)

Ports (aligns with your scheme)
	‚Ä¢	3000‚Äì3999 frontends (e.g., frontend ‚Üí 3000)
	‚Ä¢	5000‚Äì5999 backends/APIs (e.g., api ‚Üí 5001, orchestrator ‚Üí 5002)
	‚Ä¢	6000‚Äì6999 databases (local dev only)
	‚Ä¢	8000‚Äì8999 internal web APIs/webhooks

Monorepo layout

/apps
  /frontend             # SvelteKit (‚úÖ implemented)
  /orchestrator         # FastAPI + LangGraph/DSPy (üìã planned)
  /n8n                  # n8n (dockerized) (üìã planned)
  /auth                 # optional (üìã planned)
/packages
  /shared                # schemas, DTOs, UI tokens
/infra
  docker-compose.yml
  nginx/
    default.conf
    ssl/
/docs
  ARCHITECTURE.md
  WORKFLOWS.md
  ...


‚∏ª

8. Deployment on VPS (DEPLOYMENT.md)

Do things in this order (fast path): Dockerize ‚Üí Domain & Cloudflare ‚Üí Server ‚Üí SSL ‚Üí Email ‚Üí Security ‚Üí (Opt) Microservices ‚Üí CI/CD ‚Üí Monitoring.  Ôøº  Ôøº

Server: Ubuntu 22.04 LTS; 2‚Äì4GB RAM; 40GB storage; closest region; Docker, UFW, fail2ban.  Ôøº  Ôøº  Ôøº

SSL: Cloudflare Origin cert in nginx/ssl/ + ‚ÄúFull (strict)‚Äù.  Ôøº

Email: Resend SMTP with SPF/DKIM/DMARC DNS records (examples below).  Ôøº  Ôøº

CI/CD & Monitoring: GitHub Actions ‚Üí auto-build/push; UptimeRobot + Sentry + Cloudflare analytics.  Ôøº  Ôøº

‚∏ª

9. Security, Compliance & Runbooks (SECURITY_POLICY.md, RUNBOOK.md)
	‚Ä¢	Cloudflare WAF, rate limits, bot fight; Nginx security headers; fail2ban; regular audits; backups; incident response.  Ôøº  Ôøº
	‚Ä¢	Email Auth: SPF/DKIM/DMARC records as per roadmap block.  Ôøº
	‚Ä¢	Runbooks: Deployment/Incident/Maintenance/Backup‚Äîoutlined in the roadmap.  Ôøº

‚∏ª

10. Roadmap, Costs & SLOs (ROADMAP.md)
	‚Ä¢	Success metrics & SLOs: HTTPS up, A-grade SSL, 99.9% uptime, MTTR < 15m, WAF active, CI/CD < 5m.  Ôøº  Ôøº
	‚Ä¢	Cost envelope (minimum vs recommended) and quick wins.  Ôøº  Ôøº  Ôøº

Docs index & status‚Äîyou already earmarked these files to exist (ARCHITECTURE, RUNBOOK, API, SECURITY, etc.). This suite fills those in.  Ôøº  Ôøº

‚∏ª

Appendix: Implementation Snippets

A. .env.example

# App
NODE_ENV=production
PUBLIC_BASE_URL=https://yourdomain.tld

# FastAPI
API_PORT=5001
SECRET_KEY=change_me

# Supabase
SUPABASE_URL=...
SUPABASE_ANON_KEY=...
SUPABASE_SERVICE_KEY=...

# Resend SMTP
SMTP_HOST=smtp.resend.com
SMTP_PORT=587
SMTP_USER=resend
SMTP_PASS=...
SMTP_FROM=hello@yourdomain.tld

Copy into .env.production on the server; don‚Äôt commit secrets.  Ôøº

B. docker-compose.yml (prod skeleton)

version: "3.9"
services:
  frontend:
    build: ./apps/frontend
    restart: unless-stopped
    environment:
      - PUBLIC_BASE_URL=${PUBLIC_BASE_URL}
    ports: ["3000:3000"]

  api:
    build: ./apps/orchestrator_service
    restart: unless-stopped
    environment:
      - SECRET_KEY=${SECRET_KEY}
    ports: ["5001:5001"]
    depends_on: [redis, qdrant, postgres]

  n8n:
    image: n8nio/n8n:latest
    restart: unless-stopped
    ports: ["8080:5678"]
    volumes: ["./data/n8n:/home/node/.n8n"]

  nginx:
    image: nginx:stable
    volumes:
      - ./infra/nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
      - ./infra/nginx/ssl:/etc/nginx/ssl:ro
    ports: ["80:80","443:443"]
    depends_on: [frontend, api]

  redis:
    image: redis:7
  qdrant:
    image: qdrant/qdrant:latest
  postgres:
    image: supabase/postgres:15

C. infra/nginx/default.conf (TLS via Cloudflare Origin)

server {
  listen 443 ssl http2;
  server_name yourdomain.tld;

  ssl_certificate     /etc/nginx/ssl/origin.crt;
  ssl_certificate_key /etc/nginx/ssl/origin.key;

  add_header Content-Security-Policy "default-src 'self' https: data: blob:;" always;
  add_header X-Frame-Options "SAMEORIGIN" always;

  location /api/ {
    proxy_pass http://api:5001/;
  }
  location / {
    proxy_pass http://frontend:3000/;
  }
}

Use ‚ÄúFull (strict)‚Äù in Cloudflare after placing origin certs.  Ôøº

D. GitHub Actions (CI/CD)

name: deploy
on:
  push:
    branches: [main]
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - run: docker build -t agency-frontend ./apps/frontend
      - run: docker build -t agency-api ./apps/orchestrator
      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: deploy
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            cd /opt/agency && git pull
            docker compose up -d --build

CI/CD appears in your Quick Start phases; monitoring follows.  Ôøº  Ôøº

E. Resend + DNS (Cloudflare)

# .env.production (already shown)
SMTP_HOST=smtp.resend.com
# Cloudflare DNS (examples)
TXT @ "v=spf1 include:_spf.mx.cloudflare.net include:_spf.resend.com ~all"
TXT resend._domainkey "v=DKIM1; k=rsa; p=..."
TXT _dmarc "v=DMARC1; p=quarantine; rua=mailto:dmarc@yourdomain.tld; pct=100; adkim=s; aspf=s"

Mirrors your deployment roadmap blocks.  Ôøº

‚∏ª

Bonus: SvelteKit Intake ‚Üí Webhook

// apps/frontend/src/routes/intake/+page.server.ts
export const actions = {
  default: async ({ request, fetch }) => {
    const data = Object.fromEntries(await request.formData());
    const res = await fetch("/api/intake", { method: "POST", body: JSON.stringify(data) });
    return { ok: res.ok };
  }
};


‚∏ª

How this aligns with ‚ÄúThe Humachine‚Äù
	‚Ä¢	Intentionality: clear mission + values baked into agent prompts & OKRs.  Ôøº
	‚Ä¢	Integration: cross-functional teams of humans + agents + services (flat, flexible).  Ôøº
	‚Ä¢	Implementation: freedom to iterate, ship, and learn (CI/CD + runbooks).  Ôøº
	‚Ä¢	Indication: metrics & telemetry close the loop (SLOs + dashboards).  Ôøº

‚∏ª

Next Steps (immediately actionable)
	1.	Follow Quick Start order to get a live HTTPS site + working contact/email this week.  Ôøº
	2.	Import n8n flows above (lead warmup + content distribution).
	3.	Spin up orchestrator with the provided LangGraph/DSPy skeleton and stub agents.
	4.	Add monitoring (UptimeRobot, Sentry) and Cloudflare WAF/rate limits.  Ôøº  Ôøº
	5.	Iterate: capture OKRs and feed ‚ÄúIndication‚Äù back into prompts & routing.

